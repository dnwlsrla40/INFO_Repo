# Java

**목차**  

[1. Java 특징](#Java-특징)  
- [함수적 스타일 코딩을 지원한다](#함수적-스타일-코딩을-지원한다)  
- [메모리를 자동으로 관리한다](#메모리를-자동으로-관리한다)
- [멀티 스레드(Multi-Thread)를 쉽게 구현할 수 있다](#멀티-스레드(multi-thread)를-쉽게-구현할-수-있다)
- [동적 로딩(Dynamic Loading)을 지원한다](#동적-로딩(dynamic-loading)을-지원한다)

[2. 데이터 타입 종류](#데이터-타입-종류)  
- [기본 타입](#기본-타입(primitive-type))  
  - [종류](#종류)  
- [참조 타입](#참조-타입(reference-type))  
  - [종류](#종류)  
- [기본 타입 vs 참조 타입](#기본-타입-vs-참조-타입)  
- [String 객체 참조](#string-객체-참조)  
- [String 비교](#string-비교)  
  - [참조 객체 번지 비교](#참조-객체-번지-비교)  
  - [문자열 비교](#문자열-비교)  

[3. for문](#for문)
- [향상된 for문](#향상된-for문)

[4. JVM](#jvm(java-virtual-machine))  
- [메모리 사용 영역](#메모리-사용-영역)  
  - [메소드 영역](#메소드-영역)
  - [힙 영역](#힙-영역)
  - [스택 영역](#스택-영역)  
  
[5. 객체와 클래스](#객체와-클래스)  
- [클래스](#클래스)  
- [객체 간의 관계](#객체-간의-관계)  
  - [종류](#종류)
- [정적 멤버와 static](#정적-멤버와-static)  
  - [정적 멤버](#정적-멤버)  
  - [정적 멤버 선언](#정적-멤버-선어)
  - [static 선언 판단 기준](#static-선언-판단-기준)
  - [정적 초기화 블록](#정적-초기화-블록)  
- [캡슐화](#캡슐화)
  - [캡슐화 사용 이유](#캡슐화-사용-이유)  
- [싱글톤(Singleton)](#싱글톤(singleton))

## ** Java 특징**

### **함수적 스타일 코딩을 지원한다**

최근 들어 대용량 데이터의 병렬 처리 그리고 이벤트 지향 프로그래밍에 적합한 함수적 프로그래밍이 다시 부각되고 있는데, 자바는 함수적 프로그래밍을 위해 람다식을 `자바 8(Java8)`부터 지원한다.  

람다식을 사용하면 컬렉션의 요소를 필터링, 매핑, 집계 처리하는데 쉬워지고, 코드가 매우 간결해진다.

### **메모리를 자동으로 관리한다**

C++은 메모리에 생성된 객체를 제거하기 위해 개발자가 직접 코드를 작성해야 한다. 만약 이 작업을 해주지 않으면, 프로그램은 불완전해지고 갑자기 다운되는 현상을 겪게 된다.  

자바는 개발자가 직접 메모리에 접근할 수 없도록 설계(`Vertual Memory 사용`)되었으며, 메모리는 자바가 직접 관리한다. 객체 생성 시 자동적으로 메모리 영역을 찾아서 할당하고, 사용이 완료된면 `Garbage Collector`를 실행시켜 자동적으로 사용하지 않는 객체를 제거시켜준다. 따라서, 개발자는 메모리 관리의 수고스러움을 덜고, 핵심 기능 코드 작성에 집중할 수 있다.

### **멀티 스레드(Multi-Thread)를 쉽게 구현할 수 있다**  

하나의 프로그램이 동시에 여러 가지 작업을 처리해야 할 경우와 대용량 작업을 빨리 처리하기 위해 서브 작업으로 분리해서 병렬 처리하려면 멀티 스레드 프로그래밍이 필요하다. 프로그램이 실행되는 운영체제에 따라 멀티 스레드를 구현하는 방법이 다르지만, 자바는 스레드 생성 및 제어와 관련된 라이브러리 API를 제공하고 있기 때문에 운영체제에 상관없이 멀티 스레드를 쉽게 구현할 수 있다.

### **동적 로딩(Dynamic Loading)을 지원한다**

어플리케이션이 실행될 때 모든 객체가 생성되지 않고, 객체가 필요한 시접에 클래스를 동적 로딩해서 객체를 생성한다. 또한 개발 완료 후 유지보수가 발생하더라도 해당 클래스만 수정하면 되므로 전체 어플리케이션을 다시 컴파일 할 필요가 없다. 따라서 유지보수를 쉽고 빠르게 진행 할 수 있다.

## **데이터 타입 종류**

### **기본 타입(primitive type)**

 - 원시 타입이라고 함
 - byte, char, short, int, long, float, double, boolean을 이용해서 선언

### 종류

1. 정수
2. 실수
3. 문자
4. 논리 리터럴


### **참조 타입(reference type)**

 - 객체의 번지를 참조하는 타입

### 종류

1. 배열 타입
2. 열거 타입
3. 클래스
4. 인터페이스


### **기본 타입 vs 참조 타입**

기본 타입은 실제 값을 변수 안에 저장
참조 타입은 메모리의 번지를 값으로 저장

ex)
```
[기본 타입 변수]  
int age = 25;  
double price = 100.5;  

[참조 타입 변수] 
String name = "신용권";  
String hobby = "독서";  
```

![참조변수](/picture/참조변수.JPG)

### **String 객체 참조**

```
같은 String 객체 참조
String name1 = "신용권";
String name2 = "신용권";
```

![같은String객체](/picture/같은String객체.JPG) 

```
다른 String 객체 참조
String name1 = new String("신용권");
String name2 = new String("신용권");
```
![다른String객체](/picture/다른String객체.JPG)

### **String 비교**

### 참조 객체 번지 비교

```
String name1 = "신민철";
String name2 = "신민철";
String name3 = new String("신민철");

name1==name2 (true)
name1==name3 (false)
```

### 문자열 비교

```
boolean result = str1.equals(str2);
str1 - 원본 문자열
str2 - 비교 문자열
```

## **for문**

### **향상된 for문**

향상된 for문은 반복 실행을 하기 위해 카운터 변수와 증감식을 사용하지 않는다.  
배열 및 컬렉션 항목의 개수만큼 반복하고, 자동적으로 for문을 빠져나간다.

```
for(타입 변수 : 배열) {
    실행문
}
```

for문의 반복 횟수는 배열의 항목 수

## **JVM(Java Virtual Machine)**

자바 프로그램은 완전한 기계어가 아닌, 중간 단계의 바이트 코드이기 때문에 운영체제는 자바 프로그램을 바로 실행할 수 없다. 따라서, 이것을 해석하고 실행할 수 있는 가상의 운영체제가 필요하다. 이것을 자바 가상 기계(Java Virtual Machine)이라 한다.  

JVM은 실 운영체제를 대신해서 자바 프로그램을 실행하는 가상의 운영체제 역할을 한다. 따라서 개발자는 운영체제와 상관없이 자바 프로그램을 개발할 수 있다.

JVM은 JDK 또는 JRE를 설치하면 자동으로 설치되는데, 자바 프로그램을 운영체제가 이해하는 기계어로 번역해서 실행해야 하므로 JVM은 운영체제에 종속적이고 운영체제에 맞게 설치되어야 한다.

자바의 가장 큰 장점 중 하나인 "Write once, run anywhere"는 매우 매력적이지만, 한 번의 컴파일링으로 실행 가능한 기계어가 만들어지지 않고 JVM에 의해 기계어로 번역되고 실행되기 때문에 C와 C++의 컴파일 단계에서 만들어지는 완전한 기계어보다는 속도가 느리다는 단점을 가지고 있다.

![JVM 구조](/picture/JVM구조.JPG)

### **메모리 사용 영역**

java.exe로 JVM이 시작되면 JVM은 운영체제에서 할당받은 메모리 영역(Runtime Data Area)을 다음과 같이 세부 영역으로 구분해서 사용

![메모리영역](/picture/메모리영역.JPG)

### 메소드 영역(Method)

코드에서 사용되는 클래스들을 클래스 로더로 읽어 클래스 별로 런타임 상수풀(Runtime constant pool), 필드 데이터(Field data), 메소드 데이터(Method data), 메소드 코드, 생성자 코드(Constructor)로 분류해서 저장

메소드 영역은 JVM이 시작할 때 생성되고 모든 스레드가 공유하는 영역

### 힙(Heap) 영역

객체와 배열이 생성되는 영역

힙 영역에 생성된 객체와 배열은 JVM 스택 영역의 변수나 다른 객체 필드에서 참조

참조하는 변수나 필드가 없다면 의미 없는 객체가 되어 JVM은 쓰레기 수집기(Garbage Collector)을 실행시켜 힙 영역에서 자동으로 제거  
-> 자바에선 코드로 객체를 직접 제거할 필요 없음(사실은 방법을 제공 x)

### JVM 스택(Stack) 영역

각 스레드마다 하나씩 존재하며 스레드가 시작될 때 할당

추가적 스레드를 생성하지 않으면 main스레드 하나만 존재

메소드를 호출할 때마다 프레임(Frame)을 추가(push)하고 메소드가 종료되면 해당 프레임을 제거(pop)하는 동작 수행

프레임 내부에 로컬 변수 스택이 존재  
-> 기본 타입 변수와 참조 타입 변수가 추가(Push) 되거나 제거(Pop) 됨  
-> 변수가 이 영역에 생성되는 시점은 초기화가 될 때 이다(생성될 때 X)  
-> 변수는 선언된 블록에서만 스택에 존재

## **객체와 클래스**

## **클래스**

객체의 설계도가 클래스(Class)이다.

파일 이름과 동인한 클래스의 선언에만 public 접근 제한자를 붙일 수 있다.
-> 만약 파일 이름과 일치하지 않는 클래스 선언에 public 접근 제한자를 붙이면 컴파일 에러가 발생한다.

### **인스턴스**

클래스로부터 만들어진 객체를 해당 클래스의 인스터스(instance)라고 한다.

### **객체 생성**

```
new 클래스(); (new 생성자;)
```
new는 힙 영역에 객체를 생성시킨 후, 객체의 주소를 리턴

### **구성 멤버**

1. 필드 
    - 객체의 고유 데이터, 부품 객체, 상태 정보 저장
    - 변수는 생성자, 메소드와 life time 동일
    - 필드는 객체와 life time 동일

2. 생성자
    - 객체 생성 시 초기화
    - 클래스 이름으로 되어 있고 리턴 타입이 없다.
    - 생성자 오버로딩 시 생성자 간의 중복 코드 발생 가능  
&nbsp;&nbsp;&nbsp;&nbsp;-> this()이용.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;필드 초기화 내용은 한 생성자에만 집중하고 나머지 생성자는 초기화 내용을 가지고 있는 생성자를 호출
```
클래스( [매개변수 선언, ...]) {
    this(매개변수,...,값,...);
    실행문;
}
```
  
3. 메소드

### **실질적 사용**

```
[Student.java]
public  class Student {

}

[public class StudentExample]
public class StudentExample {
    public static void main(String[] args){
        Student s1 = new Student();
        System.out.println("s1 변수가 Student 객체를 참조합니다.");
        
        Student s2 = new Student();
        System.out.println("s2 변수가 또 다른 Student 객체를 찹조합니다.");
    }
}
```

s1 s2는 서로 독립된 객체 참조

**Student와 StudentExample 클래스의 용도**

Student는 라이브러리(API : Application Program Interface)용  
&nbsp;&nbsp;&nbsp;&nbsp;\- 다른 클래스에서 이용할 목적  
StudentExample은 실행용  
&nbsp;&nbsp;&nbsp;&nbsp;\- 프로그램의 실행 진입점인 main()메소드를 제공하는 역할

프로그램 전체에서 사용되는 클래스가 100개라면 99개는 라이브러리고 단 하나가 실행 클래스

### **객체 간의 관계**

객체는 개별적으로 사용될 수 있지만, 대부분 다른 객체와 관계를 맺고 있다.  
이 관계의 종류에는 집합 관계, 사용 관계, 상속 관계가 있다.

### 종류

1. 집합 관계
- 하나는 부품이고 하나는 완성품에 해당
- ex) 자동차 = 엔진, 타이어, 핸들 등으로 구성

2. 사용 관계
- 객체 간의 상호작용
- 객체는 다른 개체의 메소드를 호출하여 원하는 결과를 얻어냄
- ex) 사람은 자동차를 사용 -> 달린다, 멈춘다 등의 메소드 호출

3. 상속 관계
- 상위(부모) 객체를 기반으로 하위(자식) 객체를 생성하는 관계
- 일반적으로 상위 객체는 종류, 하위 객체는 구체적인 사물


### **정적 멤버와 static**

### 정적 멤버

클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드

이들은 각각 정적 필드와 정적 메소드라고 한다.

정적 멤버는 객체(인스턴스 instance)에 소속된 멤버가 아니라 클래스에 소속된 멤버이기 때문에 클래스 멤버라고도 한다.

### 정적 멤버 선언

정적 필드와 정적 메소드를 선언하는 방법은 필드와 메서드 선언 시 static 키워드를 추가적으로 붙이면 된다. 
```
public class 클래스 {
    // 정적 필드
    static 타입 필드 [= 초기값];

    // 정적 메소드
    static 리턴 타입 메소드 (매개변수 선언, ...) {...}
}
```
정적 필드와 정적 메소드는 클래스에 고정된 멤버로 클래스 로더가 클래스(바이트 코드)를 로딩해서 메소드 메모리 영역에 적재할 때 클래스별로 관리된다. 따라서 클래스의 로딩이 끝나면 바로 사용할 수 있다.

주로 클래스 이름과 함께 도트(.)연산자로 접근한다.


### static 선언 판단 기준

1. 필드를 선언할 때  
객체마다 가지고 있어야 할 데이터라면 인스턴스 필드로 선언하고,
객체마다 가지고 있을 필요성 없이 공용적인 데이터라면 정적 필드로 선언하는 것이 좋다.

ex) 계산기의 파이는 모든 계산기가 가지고 있어야 할 공용적인 데이터 이므로 정적 필드, 크기(size)는 계산기 마다 다를 수 있으므로 인스턴스 필드로 선언
```
public class Calculator {
    String size;
    static double pi = 3.14159;
}
```

2. 메소드를 선언할 때
인스턴스 필드를 이용해서 실행해야 한다면 인스턴스 메소드로 선언하고,
인스턴스 필드를 이용하지 않는다면 정적 메소드로 선언

ex) 계산기 클래스의 덧셈과 뺄셈 기능은 인스턴스 필드를 이용하기 보다는 외부에서 주어진 매개값들을 가지고 덧셈과 뺄셈을 수행하므로 정적 메소드로, 인스턴스 필드인 색깔을 변경하는 메소드는 인스턴스 메소드로 선언해야 한다.

### 정적 초기화 블록

정적 필드 초기화 시 계산이 필요한 초기화 작업이 필요할 수 있다.
인스턴스 필드는 생성자에서 초기화 하지만, 정적 필드는 객체 생성 없이도 사용되므로 생성자에서 초기화 작업 불가능
-> 정적 블록(static block)을 제공

```
static {
    ...
}
```

정적 블록은 클래스가 메모리로 로딩될 때 자동적으로 실행

클래스 내부에 여러개 선언되어도 상관없음
클래스가 메모리로 로딩될 때 선언된 순서대로 실행

정적 블록내부에는 인스턴스 필드나 메소드(또한, this)를 사용할 수 없다.
정적 블록에서 인스턴스 멤버를 사용하고 싶다면 객체를 먼저 생성하고 참조 변수로 접근해야 한다.

### **캡슐화(Encapsulation)**

객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것을 말한다.  
외부 객체는 객체 내부의 구조를 알지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있다.

캡슐화된 멤버를 노출시킬 것인지 결정하기 위해 접근 제한자(Access Modifier)를 사용한다.

접근 제한자는 객체의 필드와 메소드의 사용 범위를 제한함으로써 외부로부터 보호한다.

### 캡슐화 사용 이유

외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 하는 데 있다.  
즉, 정보 은닉의 이유로 사용된다.


![캡슐화](/picture/캡슐화.JPG)

### **싱글톤(Singleton)**

전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우, 이 단 하나의 객체를 싱글톤(Singleton)이라 한다.

생성자를 호출한 만큼 객체가 생성되기 때문에 싱글톤을 만들려면 클래스 외부에서 new 연산자로 생성자를 호출할 수 없도록 막아야 한다.
-> private 접근 제한자를 붙여 가능

그리고 자신의 타입인 정적 필드를 하나 선언하고 자신의 객체를 생성해 초기화한다.(클래스 내부에서는 new 연산자로 생성자 호출이 가능하다.)
정적 필드도 private 접근 제한자를 붙여 외부에서 필드값을 변경하지 못하도록 막아야 한다. 대신 외부에서 호출할 수 있는 정적 메소드인 getInstance()를 선언하고 정적 필드에서 참조하고 있는 자신의 객체를 리턴해준다.

```
public class 클래스 {
    // 정적 필드
    private static 클래스 singleton = new 클래스();

    // 생성자
    private 클래스() {

    }

    // 정적 메소드
    static 클래스 getInstance() {
        return singleton;
    }
}

getInstance() 메소드는 단 하나의 객체만 리턴하기 때문에 클래스.getInstance()는 모두 같은 객체를 참조한다.
